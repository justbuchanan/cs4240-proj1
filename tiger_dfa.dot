digraph tiger {
	//	start state
	S;

	//	syntax error
	Error [color=red, shape=diamond];

	//	token types
	node [shape=doublecircle];
	S -> COMMA [label=","];
	S -> COLON [label=":"];
	S -> SEMI [label=";"];
	S -> LPAREN [label="("];
	S -> RPAREN [label=")"];
	S -> LBRACK [label="["];
	S -> RBRACK [label="]"];
	S -> LBRACE [label="{"];
	S -> RBRACE [label="}"];
	S -> PERIOD [label="."];
	S -> PLUS [label="+"];
	S -> MINUS [label="-"];
	S -> MULT [label="*"];
	S -> DIV [label="/"];
	S -> EQ [label="="];
	
	S -> NEQ_ [label="!"];
	NEQ_ [shape="circle"];
	NEQ_ -> NEQ [label="="];

	S -> LESSER [label="<"];
	S -> GREATER [label=">"];
	S -> LESSEREQ [label="<="];
	S -> GREATEREQ [label=">="];
	S -> AND [label=""];
	S -> OR [label=""];
	S -> ASSIGN [label=""];

	//	keywords
	ARRAY
	S -> a [label="a"];
	a [label="a (identifier)"];
	a -> ar [label="r"];
	a -> ID [label="[^r]"];
	ar [label="ar (identifier)"];
	ar -> arr [label="r"];
	ar -> ID [label="[^r]"];
	arr [label="arr (identifier)"];
	arr -> arra [label="a"];
	arr -> ID [label="[^a]"];
	arra [label="arra (identifier)"];
	arra -> ARRAY [label="y"];
	arra -> ID [label="[^y]"];

	//	TODO: tim
	BREAK
	BEGIN
	DO
	FOR 
	FUNC
	VAR

	//	TODO: matt
	IF;
	S -> i [label="i"];
	i [label="i (identifier)"];
	i -> ID [label="[^(fn)]"];
	i -> IF [label="f"];


	IN;
	i -> IN [label="n"];

	LET;
	S -> l [label="l"];
	l [label="l (identifier)"];
	l -> ID [label="[^e]"];
	l -> le [label="e"];
	le [label="le (identifier)"];
	le -> ID [label="[^t]"];
	le -> LET [label ="t"];

	OF;
	S-> o [label="o"];
	o [label="o (identifier)"];
	o -> ID [label="[^f]"];
	o -> OF [label="f"];

	THEN; 
	TO
	TYPE


	ENDIF;
	S -> e [label="e"];
	e [label="e (identifier)"];
	e -> ID [label="[^nl]"];//
	e -> en [label="n"];
	en [label="en (identifier)"];
	en -> ID [label="[^d]"];
	en -> END [label="d"];
	END;//
	END -> ID [label="[^di]"];//
	END -> endi [label="i"];
	endi [label="endi (identifier)"];
	endi -> ID [label="[^f]"];
	endi -> ENDIF [label="f"];


	ENDDO;
	END -> endd [label="d"];
	endd -> ENDDO [label="o"];
	endd [label="endd (identifier)"];
	endd -> ID [label="[^o]"];


	ELSE;
	e -> el [label="e"];
	el [label="el (identifier)"];
	el -> els [label="s"];
	el -> ID [label="[^s]"];
	els [label="els (identifier)"];
	els -> ELSE [label="e"];
	els -> ID [label="[^e]"];


	END;


	//	TODO: justin
	WHILE;
	S -> w [label="w"];
	w -> wh [label="h"];
	w -> ID [label="[^h]"];
	w [label="w (identifier)"];
	wh -> whi [label="i"];
	wh -> ID [label="[^i]"];
	wh [label="wh (identifier)"];
	whi -> whil [label="l"];
	whi -> ID [label="[^l]"];
	whi [label="whi (identifier)"];
	whil -> WHILE [label="e"];
	whil -> ID [label="[^e]"];
	whil [label="whil (identifier)"];


	NIL;
	S -> n;
	n -> ni [label="i"];
	n -> ID [label="[^i]"];
	n [label="n (identifier)"];
	ni -> NIL [label="l"];
	ni -> ID [label="[^l]"];
	ni [label="ni (identifier)"];


	//	data
	ID;
	S -> ID [label="[a-zA-Z_]"];
	ID -> ID [label="[a-zA-Z0-9_]"];

	INTLIT;
	S -> INTLIT [label="[0-9]"];
	INTLIT -> INTLIT [label="[0-9]"];

	STRLIT;
	STRLIT_PART [shape=circle];	//	not an accept state
	S -> STRLIT_PART [label="\""];
	STRLIT_PART -> STRLIT_PART [label="[^\"]"];	//	FIXME: is regex ok?
	STRLIT_PART -> STRLIT [label="\""];
}