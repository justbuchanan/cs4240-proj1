digraph tiger {
	//	start state
	S;

	//	syntax error
	Error [color=red, shape=diamond];

	//	token types
	node [shape=doublecircle];
	S -> COMMA [label=","];
	S -> COLON [label=":"];
	S -> SEMI [label=";"];
	S -> LPAREN [label="("];
	S -> RPAREN [label=")"];
	S -> LBRACK [label="["];
	S -> RBRACK [label="]"];
	S -> LBRACE [label="{"];
	S -> RBRACE [label="}"];
	S -> PERIOD [label="."];
	S -> PLUS [label="+"];
	S -> MINUS [label="-"];
	S -> MULT [label="*"];
	S -> DIV [label="/"];
	S -> EQ [label="="];
	
	S -> NEQ_ [label="!"];
	NEQ_ [shape="circle"];
	NEQ_ -> NEQ [label="="];

	S -> LESSER [label="<"];
	S -> GREATER [label=">"];
	S -> LESSEREQ [label="<="];
	S -> GREATEREQ [label=">="];
	S -> AND [label=""];
	S -> OR [label=""];
	S -> ASSIGN [label=""];

	//	keywords
	ARRAY
	S -> a [label="a"];
	a [label="a (identifier)"];
	a -> ar [label="r"];
	a -> ID [label="[^r]"];
	ar [label="ar (identifier)"];
	ar -> arr [label="r"];
	ar -> ID [label="[^r]"];
	arr [label="arr (identifier)"];
	arr -> arra [label="a"];
	arr -> ID [label="[^a]"];
	arra [label="arra (identifier)"];
	arra -> ARRAY [label="y"];
	arra -> ID [label="[^y]"];

	//	TODO: tim
	BREAK
	S -> b [label="b"];
	b [label="b (identifier)"];
	b -> br [label="r"];
	b -> ID [label="[^r^e]"];
	br [label="br (identifier)"];
	br -> bre [label="e"];
	br -> ID [label="[^e]"];
	bre [label="bre (identifier)"];
	bre -> brea [label="a"];
	bre -> ID [label="[^a]"];
	brea [label="brea (identifier)"];
	brea -> BREAK [label="k"];
	brea -> ID [label="[^k]"];

	BEGIN
	b -> eBEGIN [label="e"];
	eBEGIN [label="be (identifier)"];
	eBEGIN -> g [label="g"];
	eBEGIN -> ID [label="[^g]"];
	g [label="beg (identifier)"];
	g -> i [label="i"];
	g -> ID [label="[^i]"];
	i [label="begi (identifier)"];
	i -> BEGIN[label="n"];
	i -> ID [label="[^n]"];

	DO
	S -> d [label="d"];
	d [label="d (identifier)"];	
	d -> ID [label="[^o]"];
	d -> DO [label="o"];
	FOR
	S -> f [label="f"];
	f [label="f (identifier)"];
	f -> fo [label="o"];
	f -> ID [label="[^o^u]"];
	fo [label="fo (identifier)"];
	fo -> FOR [label="r"];
	fo -> ID [label="[^e]"];
	FUNC
	f -> fu [label="u"];
	fu [label="fu (identifier)"];
	fu -> ID [label="[^n]"];
	fu -> fun [label="n"];
	fun -> FUNC [label="c"];
	fun -> ID [label="[^c]"];
	fun [label="fun (identifier)"];
	VAR
	S -> v [label="v"];
	v [label="v (identifier)"];
	v -> va [label="a"];
	v -> ID [label="[^a]"];
	va [label="va (identifier)"];
	va -> VAR [label="r"];
    va -> ID [label="[^r]"];

	//	TODO: matt
	IF;
	S -> i [label="i"];
	i [label="i (identifier)"];
	i -> ID [label="[^(f | n)]"];
	i -> IF [label="f"];


	IN;
	i -> IN [label="n"];

	LET;
	S -> l [label="l"];
	l [label="l (identifier)"];
	l -> ID [label="[^e]"];
	l -> le [label="e"];
	le [label="le (identifier)"];
	le -> ID [label="[^t]"];
	le -> LET [label ="t"];

	OF;
	S-> o [label="o"];
	o [label="o (identifier)"];
	o -> ID [label="[^f]"];
	o -> OF [label="f"];

	THEN;
	S -> t [label="t"];
	t [label="t (identifier)"];
	t -> ID [label="[^(h | o | y | e)]"];
	t -> th [label="h"];
	th [label="th (identifier)"];
	th -> ID [label="[^e]"];
	th -> the [label="e"];
	the [label="the (identifier)"];
	the -> ID [label="[^n]"];
	the -> THEN [label="n"];

	TO;
	t -> TO [label="o"];

	TYPE;
	t -> ty [label ="y"];
	ty [label="ty (identifier)"];
	ty -> ID [label="[^p]"];
	ty -> typ [label="p"];
	typ [label="typ (identifier)"];
	typ -> ID [label="[^e]"];
	typ -> TYPE [label="e"];


	ENDIF;
	S -> e [label="e"];
	e [label="e (identifier)"];
	e -> ID [label="[^nl]"];//
	e -> en [label="n"];
	en [label="en (identifier)"];
	en -> ID [label="[^d]"];
	en -> END [label="d"];
	END;//
	END -> ID [label="[^di]"];//
	END -> endi [label="i"];
	endi [label="endi (identifier)"];
	endi -> ID [label="[^f]"];
	endi -> ENDIF [label="f"];


	ENDDO;
	END -> endd [label="d"];
	endd -> ENDDO [label="o"];
	endd [label="endd (identifier)"];
	endd -> ID [label="[^o]"];


	ELSE;
	e -> el [label="e"];
	el [label="el (identifier)"];
	el -> els [label="s"];
	el -> ID [label="[^s]"];
	els [label="els (identifier)"];
	els -> ELSE [label="e"];
	els -> ID [label="[^e]"];


	END;


	//	TODO: justin
	WHILE;
	S -> w [label="w"];
	w -> wh [label="h"];
	w -> ID [label="[^h]"];
	w [label="w (identifier)"];
	wh -> whi [label="i"];
	wh -> ID [label="[^i]"];
	wh [label="wh (identifier)"];
	whi -> whil [label="l"];
	whi -> ID [label="[^l]"];
	whi [label="whi (identifier)"];
	whil -> WHILE [label="e"];
	whil -> ID [label="[^e]"];
	whil [label="whil (identifier)"];


	NIL;
	S -> n;
	n -> ni [label="i"];
	n -> ID [label="[^i]"];
	n [label="n (identifier)"];
	ni -> NIL [label="l"];
	ni -> ID [label="[^l]"];
	ni [label="ni (identifier)"];


	//	data
	ID;
	S -> ID [label="[a-zA-Z_]"];
	ID -> ID [label="[a-zA-Z0-9_]"];

	INTLIT;
	S -> INTLIT [label="[0-9]"];
	INTLIT -> INTLIT [label="[0-9]"];

	STRLIT;
	STRLIT_PART [shape=circle];	//	not an accept state
	S -> STRLIT_PART [label="\""];
	STRLIT_PART -> STRLIT_PART [label="[^\"]"];	//	FIXME: is regex ok?
	STRLIT_PART -> STRLIT [label="\""];
}